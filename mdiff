diff --git a/dcp/DcpHandler.go b/dcp/DcpHandler.go
index a8a8deb..1c1ccd7 100644
--- a/dcp/DcpHandler.go
+++ b/dcp/DcpHandler.go
@@ -333,7 +333,7 @@ func (m *Mutation) SimulateImport(agent *gocbcore.Agent, logger *xdcrLog.CommonL
 			return err
 		}
 
-		logger.Debugf("For key %s, colId %v, casIn %v, importCasIn %v, syncCasIn %v: casNow %v, cvCasNow %v, syncCasNow %v, revIdNow %v, importCasNow %v", key, colID, casIn, importCasIn, syncCasIn, casNow, cvCasNow, syncCasNow, revIdNow, importCasNow)
+		logger.Infof("For key %s, colId %v, casIn %v, importCasIn %v, syncCasIn %v: casNow %v, cvCasNow %v, syncCasNow %v, revIdNow %v, importCasNow %v", key, colID, casIn, importCasIn, syncCasIn, casNow, cvCasNow, syncCasNow, revIdNow, importCasNow)
 		if casIn > syncCasNow {
 			// only process the mutation, if it has not been processed before i.e if casIn > syncCasNow.
 
@@ -342,20 +342,20 @@ func (m *Mutation) SimulateImport(agent *gocbcore.Agent, logger *xdcrLog.CommonL
 			// 3. casIn > importCasIn											-> non-import mutation - update both importCas and HLV.
 
 			if casIn > importCasIn {
-				postImportCas, err := gocbcoreUtils.WriteImportMutation(agent, key, importCasIn, casNow, revIdNow, srcNow, verNow, pvNow, mvNow, oldPvLen, oldMvLen, colID, bucketUUID, casNow > cvCasNow)
+				postImportCas, err := gocbcoreUtils.WriteImportMutation(agent, key, casIn, importCasIn, casNow, revIdNow, srcNow, verNow, pvNow, mvNow, oldPvLen, oldMvLen, colID, bucketUUID, casNow > cvCasNow)
 				if err != nil {
 					logger.Errorf("For key %s, colId %v, error while subdoc-set err=%v\n", key, colID, err)
 					return err
 				}
-				logger.Debugf("For key %s, colId %v, casIn %v: non-import mutation: postImportCas %v", key, colID, casIn, postImportCas)
+				logger.Infof("For key %s, colId %v, casIn %v: non-import mutation: postImportCas %v", key, colID, casIn, postImportCas)
 				importedCnt++
 			} else if syncCasIn != 0 && casIn > syncCasIn {
-				postImportCas, err := gocbcoreUtils.WriteImportMutation(agent, key, importCasIn, casNow, revIdNow, srcNow, verNow, pvNow, mvNow, oldPvLen, oldMvLen, colID, bucketUUID, false)
+				postImportCas, err := gocbcoreUtils.WriteImportMutation(agent, key, casIn, importCasIn, casNow, revIdNow, srcNow, verNow, pvNow, mvNow, oldPvLen, oldMvLen, colID, bucketUUID, false)
 				if err != nil {
 					logger.Errorf("For key %s, colId %v, error while subdoc-set err=%v\n", key, colID, err)
 					return err
 				}
-				logger.Debugf("For key %s, colId %v, casIn %v: non-local post-import mutation: postImportCas %v", key, colID, casIn, postImportCas)
+				logger.Infof("For key %s, colId %v, casIn %v: non-local post-import mutation: postImportCas %v", key, colID, casIn, postImportCas)
 				importedCnt++
 			}
 		}
diff --git a/gocbcoreUtils/GocbcoreAgent.go b/gocbcoreUtils/GocbcoreAgent.go
index 96244ab..8d1aee0 100644
--- a/gocbcoreUtils/GocbcoreAgent.go
+++ b/gocbcoreUtils/GocbcoreAgent.go
@@ -31,7 +31,7 @@ type SubdocSetResult struct {
 }
 
 // return Cas post-import and error, if any
-func WriteImportMutation(agent *gocbcore.Agent, key []byte, importCasIn, casNow, revIdNow uint64, srcNow xdcrHLV.DocumentSourceId, verNow uint64, pvNow, mvNow xdcrHLV.VersionsMap, oldPvLen, oldMvLen uint64, colID uint32, bucketUUID string, updateHLV bool) (uint64, error) {
+func WriteImportMutation(agent *gocbcore.Agent, key []byte, casIn, importCasIn, casNow, revIdNow uint64, srcNow xdcrHLV.DocumentSourceId, verNow uint64, pvNow, mvNow xdcrHLV.VersionsMap, oldPvLen, oldMvLen uint64, colID uint32, bucketUUID string, updateHLV bool) (uint64, error) {
 	signal := make(chan SubdocSetResult)
 	src, err := xdcrBase.HexToBase64(bucketUUID)
 	if err != nil {
@@ -68,6 +68,7 @@ func WriteImportMutation(agent *gocbcore.Agent, key []byte, importCasIn, casNow,
 	pvBytes = pvBytes[:pos]
 
 	casNowBytes := []byte("\"" + string(xdcrBase.Uint64ToHexLittleEndian(casNow)) + "\"")
+	casInBytes := []byte("\"" + string(xdcrBase.Uint64ToHexLittleEndian(casIn)) + "\"")
 
 	ops := make([]gocbcore.SubDocOp, 0)
 
@@ -91,12 +92,12 @@ func WriteImportMutation(agent *gocbcore.Agent, key []byte, importCasIn, casNow,
 			Value: []byte(revID),
 		})
 	}
-	// _sync.simCas = macro expandaded (???)
+	// _sync.simCas = casIn of the mutation
 	ops = append(ops, gocbcore.SubDocOp{
 		Op:    memd.SubDocOpType(memd.CmdSubDocDictSet),
 		Flags: memd.SubdocFlagMkDirP | memd.SubdocFlagXattrPath | memd.SubdocFlagExpandMacros,
 		Path:  XATTR_SYNC,
-		Value: []byte(xdcrBase.CAS_MACRO_EXPANSION),
+		Value: casInBytes,
 	})
 
 	if updateHLV {
